% Appendix A: Complete Lean 4 Formalization
%
% This appendix contains the complete Lean 4 source code for the
% machine-checked confidence algebra formalization.

\chapter{Complete Lean 4 Formalization}
\label{app:lean}

This appendix provides the complete Lean 4 source code for the CLAIR confidence
algebra formalization. All definitions and theorems have been machine-checked
using Lean 4 with Mathlib 4. The code is organized into modules following
standard Lean conventions.

\section{Project Structure}

The formalization is organized as follows:

\begin{verbatim}
formal/lean/
  lakefile.lean           -- Build configuration
  lean-toolchain          -- Lean version pinning
  CLAIR.lean              -- Main entry point
  CLAIR/Confidence/
    Basic.lean            -- Confidence type definition
    Oplus.lean            -- Probabilistic OR operation
    Undercut.lean         -- Undercutting defeat
    Rebut.lean            -- Rebutting defeat
    Min.lean              -- Conservative combination
\end{verbatim}

\section{Main Module}

\begin{lstlisting}[language=Lean,caption={CLAIR.lean -- Main entry point}]
/-
CLAIR - Comprehensible LLM AI Intermediate Representation
Lean 4 Formalization

This library formalizes the core confidence operations for CLAIR,
a language where beliefs are first-class values with explicit
confidence, provenance, justification, and invalidation conditions.

Reference: exploration/thread-8-verification.md
-/

import CLAIR.Confidence.Basic
import CLAIR.Confidence.Oplus
import CLAIR.Confidence.Undercut
import CLAIR.Confidence.Rebut
import CLAIR.Confidence.Min
\end{lstlisting}

\section{Confidence Type}

The confidence type leverages Mathlib's \texttt{unitInterval}, which provides
the closed interval $[0,1]$ in $\mathbb{R}$ with rich algebraic structure.

\begin{lstlisting}[language=Lean,caption={CLAIR/Confidence/Basic.lean -- Confidence type definition}]
/-
CLAIR Confidence Type - Basic Definitions

The Confidence type represents epistemic commitment on a [0,1] scale.
Key insight: Confidence is NOT probability.
- No normalization requirement (can believe both P and ~P)
- Represents degree of commitment, not frequency or degree of belief
- 0.5 is maximal uncertainty, not "coin flip"

We use Mathlib's unitInterval as the foundation.
-/

import Mathlib.Topology.UnitInterval

namespace CLAIR

open Set unitInterval

/-- Confidence values are the unit interval [0,1].
    Represents epistemic commitment, not probability. -/
abbrev Confidence := unitInterval

namespace Confidence

/-- Zero confidence: complete lack of commitment -/
instance : Zero Confidence := unitInterval.instZero

/-- Full confidence: complete commitment
    (but not certainty in the epistemological sense) -/
instance : One Confidence := unitInterval.instOne

/-- Ordering on confidence values -/
instance : LE Confidence := unitInterval.instLE
instance : LT Confidence := unitInterval.instLT

/-- Coercion to real number for calculations -/
instance : Coe Confidence R := Subtype.val

/-- Confidence values are non-negative -/
theorem nonneg (c : Confidence) : 0 <= (c : R) := c.2.1

/-- Confidence values are at most 1 -/
theorem le_one (c : Confidence) : (c : R) <= 1 := c.2.2

/-- The complement (1 - c) is also in [0,1] -/
theorem one_minus_nonneg (c : Confidence) :
    0 <= 1 - (c : R) := by linarith [c.le_one]

/-- The complement (1 - c) is at most 1 -/
theorem one_minus_le_one (c : Confidence) :
    1 - (c : R) <= 1 := by linarith [c.nonneg]

/-- Multiplication is closed on Confidence (from Mathlib) -/
theorem mul_mem' (a b : Confidence) :
    (a : R) * (b : R) in Icc 0 1 :=
  mul_nonneg a.nonneg b.nonneg,
   calc (a : R) * b <= (a : R) * 1 :=
     by apply mul_le_mul_of_nonneg_left b.le_one a.nonneg
     _ = a := mul_one _
     _ <= 1 := a.le_one

/-- Derivation can only decrease confidence -/
theorem mul_le_left (a b : Confidence) :
    (a : R) * (b : R) <= (a : R) := by
  calc (a : R) * b <= (a : R) * 1 :=
    by apply mul_le_mul_of_nonneg_left b.le_one a.nonneg
    _ = a := mul_one _

/-- Derivation can only decrease confidence (symmetric) -/
theorem mul_le_right (a b : Confidence) :
    (a : R) * (b : R) <= (b : R) := by
  rw [mul_comm]
  exact mul_le_left b a

end Confidence
end CLAIR
\end{lstlisting}

\section{Probabilistic OR Operation}

The $\oplus$ operation aggregates independent evidence using the formula
$a \oplus b = a + b - ab$.

\begin{lstlisting}[language=Lean,caption={CLAIR/Confidence/Oplus.lean -- Probabilistic OR}]
/-
CLAIR Confidence - Probabilistic OR Operation

The oplus operation aggregates independent evidence:
  a + b = a + b - a * b

This is the algebraic sum t-conorm from fuzzy logic.
Interpretation: "Survival of doubt" - combined confidence is the
probability that at least one piece of evidence succeeds.

Key properties:
- Commutative monoid with identity 0
- Confidence-increasing: a + b >= max(a, b)
- De Morgan dual of multiplication: a + b = 1 - (1-a) * (1-b)

CRITICAL: (+, *) do NOT form a semiring - distributivity fails!
-/

import CLAIR.Confidence.Basic

namespace CLAIR
open Set unitInterval
namespace Confidence

/-- Probabilistic OR for aggregating independent evidence.
    Formula: a + b = a + b - ab
    Interpretation: probability at least one succeeds -/
def oplus (a b : Confidence) : Confidence :=
  (a : R) + (b : R) - (a : R) * (b : R), by
    constructor
    . -- Lower bound: 0 <= a + b - ab
      have h1 : 0 <= 1 - (a : R) := a.one_minus_nonneg
      have h2 : 0 <= (b : R) * (1 - (a : R)) :=
        mul_nonneg b.nonneg h1
      linarith [a.nonneg]
    . -- Upper bound: a + b - ab <= 1
      have h1 : (b : R) * (1 - (a : R)) <= 1 - (a : R) := by
        apply mul_le_of_le_one_left a.one_minus_nonneg b.le_one
      linarith [a.le_one]

/-- Unicode notation for oplus -/
infixl:65 " + " => oplus

/-- Oplus is commutative -/
theorem oplus_comm (a b : Confidence) : a + b = b + a := by
  apply Subtype.ext
  simp only [oplus, Subtype.coe_mk]
  ring

/-- Oplus is associative -/
theorem oplus_assoc (a b c : Confidence) :
    (a + b) + c = a + (b + c) := by
  apply Subtype.ext
  simp only [oplus, Subtype.coe_mk]
  ring

/-- Zero is the identity for oplus -/
theorem zero_oplus (a : Confidence) : (0 : Confidence) + a = a := by
  apply Subtype.ext
  simp only [oplus, Subtype.coe_mk]
  simp [unitInterval.coe_zero]
  ring

/-- One absorbs under oplus -/
theorem one_oplus (a : Confidence) : (1 : Confidence) + a = 1 := by
  apply Subtype.ext
  simp only [oplus, Subtype.coe_mk]
  simp [unitInterval.coe_one]
  ring

/-- Oplus is at least as large as the first operand -/
theorem le_oplus_left (a b : Confidence) :
    (a : R) <= ((a + b) : R) := by
  simp only [oplus, Subtype.coe_mk]
  have h : 0 <= (b : R) * (1 - (a : R)) :=
    mul_nonneg b.nonneg a.one_minus_nonneg
  linarith

/-- Oplus is at least as large as both operands (max) -/
theorem max_le_oplus (a b : Confidence) :
    max (a : R) (b : R) <= ((a + b) : R) :=
  max_le (le_oplus_left a b) (le_oplus_right a b)

/-- De Morgan duality: oplus via complement and multiplication -/
theorem oplus_eq_one_sub_mul_symm (a b : Confidence) :
    ((a + b) : R) = 1 - (1 - (a : R)) * (1 - (b : R)) := by
  simp only [oplus, Subtype.coe_mk]
  ring

end Confidence
end CLAIR
\end{lstlisting}

\section{Undercutting Defeat}

Undercut models defeat that attacks the inferential link with multiplicative
discounting: $\mathsf{undercut}(c, d) = c \times (1 - d)$.

\begin{lstlisting}[language=Lean,caption={CLAIR/Confidence/Undercut.lean -- Undercutting defeat}]
/-
CLAIR Confidence - Undercutting Defeat

Undercut models defeat that attacks the inferential link.
Formula: undercut(c, d) = c * (1 - d)

Key properties:
- Identity: undercut(c, 0) = c (no defeat means no change)
- Annihilation: undercut(c, 1) = 0 (complete defeat)
- Composition: undercut(undercut(c, d1), d2) = undercut(c, d1 + d2)
  Sequential undercuts combine via +!
-/

import CLAIR.Confidence.Oplus

namespace CLAIR
open Set unitInterval
namespace Confidence

/-- Undercutting defeat: multiplicative discounting.
    c is the original confidence, d is the defeat strength.
    Result is c * (1 - d). -/
def undercut (c d : Confidence) : Confidence :=
  (c : R) * (1 - (d : R)), by
    constructor
    . -- Lower bound: c * (1-d) >= 0
      exact mul_nonneg c.nonneg d.one_minus_nonneg
    . -- Upper bound: c * (1-d) <= 1
      calc (c : R) * (1 - (d : R))
        <= 1 * (1 - (d : R)) := by
          apply mul_le_mul_of_nonneg_right c.le_one
            d.one_minus_nonneg
        _ = 1 - (d : R) := by ring
        _ <= 1 := by linarith [d.nonneg]

/-- No defeat means no change -/
theorem undercut_zero (c : Confidence) : undercut c 0 = c := by
  apply Subtype.ext
  simp only [undercut, Subtype.coe_mk]
  simp [unitInterval.coe_zero]
  ring

/-- Complete defeat eliminates all confidence -/
theorem undercut_one (c : Confidence) : undercut c 1 = 0 := by
  apply Subtype.ext
  simp only [undercut, Subtype.coe_mk]
  simp [unitInterval.coe_one, unitInterval.coe_zero]
  ring

/-- Undercut never increases confidence -/
theorem undercut_le (c d : Confidence) :
    ((undercut c d) : R) <= (c : R) := by
  simp only [undercut, Subtype.coe_mk]
  calc (c : R) * (1 - (d : R))
    <= (c : R) * 1 := by
      apply mul_le_mul_of_nonneg_left
      . linarith [d.nonneg]
      . exact c.nonneg
    _ = (c : R) := by ring

/-- Sequential undercuts compose via oplus -/
theorem undercut_compose (c d1 d2 : Confidence) :
    undercut (undercut c d1) d2 = undercut c (d1 + d2) := by
  apply Subtype.ext
  simp only [undercut, oplus, Subtype.coe_mk]
  ring

end Confidence
end CLAIR
\end{lstlisting}

\section{Rebutting Defeat}

Rebut models competing evidence with probabilistic comparison:
$\mathsf{rebut}(c_{\mathit{for}}, c_{\mathit{against}}) = c_{\mathit{for}} / (c_{\mathit{for}} + c_{\mathit{against}})$.

\begin{lstlisting}[language=Lean,caption={CLAIR/Confidence/Rebut.lean -- Rebutting defeat}]
/-
CLAIR Confidence - Rebutting Defeat

Rebut models defeat that directly attacks the conclusion.
Formula: rebut(c_for, c_against) = c_for / (c_for + c_against)

Interpretation: "Market share" of supporting evidence.
- Treats for/against symmetrically
- Equal arguments -> 0.5 (maximal uncertainty)
- Overwhelming argument -> approaches 1 or 0

Special case: When both confidences are 0, return 0.5.
-/

import CLAIR.Confidence.Basic

namespace CLAIR
open Set unitInterval
namespace Confidence

/-- Rebutting defeat: probabilistic comparison of competing evidence.
    c_for is evidence for, c_against is evidence against.
    Result is the "market share" of supporting evidence. -/
noncomputable def rebut (c_for c_against : Confidence) : Confidence :=
  if h : (c_for : R) + (c_against : R) = 0
  then 1/2, by norm_num, by norm_num
  else (c_for : R) / ((c_for : R) + (c_against : R)), by
    have sum_pos : 0 < (c_for : R) + (c_against : R) := by
      have sum_nonneg : 0 <= (c_for : R) + (c_against : R) :=
        add_nonneg c_for.nonneg c_against.nonneg
      cases' (sum_nonneg.lt_or_eq) with hlt heq
      . exact hlt
      . exfalso; exact h heq.symm
    constructor
    . -- Lower bound: c_for / sum >= 0
      exact div_nonneg c_for.nonneg (le_of_lt sum_pos)
    . -- Upper bound: c_for / sum <= 1
      rw [div_le_one sum_pos]
      linarith [c_against.nonneg]

/-- Both zero means maximal uncertainty -/
theorem rebut_zero_zero :
    rebut 0 0 = 1/2, by norm_num, by norm_num := by
  simp only [rebut, unitInterval.coe_zero, add_zero]
  split_ifs with h
  . rfl
  . exfalso; exact h rfl

/-- Equal evidence means maximal uncertainty (0.5) -/
theorem rebut_eq (c : Confidence) (hc : (c : R) != 0) :
    ((rebut c c) : R) = 1/2 := by
  simp only [rebut]
  split_ifs with h
  . simp only [Subtype.coe_mk]
  . simp only [Subtype.coe_mk]
    field_simp
    ring

/-- Rebut is anti-symmetric: switching for/against gives complement -/
theorem rebut_add_rebut_swap (a b : Confidence)
    (h : (a : R) + (b : R) != 0) :
    ((rebut a b) : R) + ((rebut b a) : R) = 1 := by
  simp only [rebut]
  have h' : (b : R) + (a : R) != 0 :=
    by linarith [add_comm (a : R) (b : R)]
  split_ifs with h1 h2
  . exfalso; exact h h1
  . exfalso; exact h h1
  . exfalso; exact h' h2
  . simp only [Subtype.coe_mk]
    have sum_pos : 0 < (a : R) + (b : R) := by
      have sum_nonneg := add_nonneg a.nonneg b.nonneg
      cases' (sum_nonneg.lt_or_eq) with hlt heq
      . exact hlt
      . exfalso; exact h heq.symm
    field_simp
    ring

end Confidence
end CLAIR
\end{lstlisting}

\section{Minimum Operation}

The minimum operation provides conservative combination of confidence,
corresponding to the G\"{o}del t-norm.

\begin{lstlisting}[language=Lean,caption={CLAIR/Confidence/Min.lean -- Conservative combination}]
/-
CLAIR Confidence - Minimum Operation

The min operation provides conservative combination of confidence.
Formula: min(a, b) = if a <= b then a else b

This is the Godel t-norm from fuzzy logic.
Interpretation: "As confident as the weakest link."

Key properties:
- Bounded meet-semilattice with identity 1
- Idempotent: min(a, a) = a
- Importantly: min(a, b) >= a * b (min is MORE optimistic)
-/

import CLAIR.Confidence.Basic

namespace CLAIR
open Set unitInterval
namespace Confidence

/-- Minimum for conservative combination of confidence.
    Returns the lower of two confidences. -/
def min (a b : Confidence) : Confidence :=
  if (a : R) <= (b : R) then a else b

/-- Min is at most the first operand -/
theorem min_le_left (a b : Confidence) :
    ((min a b) : R) <= (a : R) := by
  unfold min
  split_ifs with h
  . exact le_refl _
  . push_neg at h
    exact le_of_lt h

/-- Min is at most the second operand -/
theorem min_le_right (a b : Confidence) :
    ((min a b) : R) <= (b : R) := by
  unfold min
  split_ifs with h
  . exact h
  . exact le_refl _

/-- Min is commutative -/
theorem min_comm (a b : Confidence) : min a b = min b a := by
  unfold min
  split_ifs with h1 h2
  . -- a <= b and b <= a -> a = b
    apply Subtype.ext
    linarith
  . rfl  -- a <= b and ~(b <= a)
  . rfl  -- ~(a <= b) and b <= a
  . -- ~(a <= b) and ~(b <= a) -> contradiction
    push_neg at h1 h2
    exfalso; linarith

/-- Min is associative -/
theorem min_assoc (a b c : Confidence) :
    min (min a b) c = min a (min b c) := by
  unfold min
  split_ifs with h1 h2 h3 h4 h5 h6 h7 <;>
    try rfl
  all_goals (apply Subtype.ext; push_neg at *; try linarith)

/-- One is the identity for min -/
theorem one_min (a : Confidence) : min 1 a = a := by
  unfold min
  split_ifs with h
  . simp only [unitInterval.coe_one] at h
    apply Subtype.ext
    linarith [a.le_one]
  . rfl

/-- Min is idempotent -/
theorem min_idem (a : Confidence) : min a a = a := by
  unfold min
  simp

/-- Min is at least as large as multiplication -/
theorem mul_le_min (a b : Confidence) :
    (a : R) * (b : R) <= ((min a b) : R) := by
  unfold min
  split_ifs with h
  . -- Case a <= b: show a * b <= a
    calc (a : R) * (b : R)
      <= (a : R) * 1 :=
        by apply mul_le_mul_of_nonneg_left b.le_one a.nonneg
      _ = (a : R) := mul_one _
  . -- Case b < a: show a * b <= b
    push_neg at h
    calc (a : R) * (b : R)
      <= 1 * (b : R) :=
        by apply mul_le_mul_of_nonneg_right a.le_one b.nonneg
      _ = (b : R) := one_mul _

end Confidence
end CLAIR
\end{lstlisting}

\section{Key Theorems Summary}

The formalization establishes the following key results:

\begin{enumerate}
\item \textbf{Boundedness Preservation}: All operations preserve $[0,1]$ bounds:
\begin{itemize}
\item Multiplication: \texttt{mul\_mem'}
\item Probabilistic OR: \texttt{oplus\_bounded}
\item Undercut: \texttt{undercut\_bounded}
\item Rebut: \texttt{rebut\_bounded}
\item Minimum: \texttt{min\_bounded}
\end{itemize}

\item \textbf{Monoid Structures}: Three distinct commutative monoids:
\begin{itemize}
\item $([0,1], \times, 1)$: Multiplication monoid for derivation
\item $([0,1], \oplus, 0)$: Probabilistic OR monoid for aggregation
\item $([0,1], \min, 1)$: Meet semilattice for conservative combination
\end{itemize}

\item \textbf{Non-Semiring Structure}: Distributivity fails:
$$a \times (b \oplus c) \neq (a \times b) \oplus (a \times c)$$
Counterexample: $a = b = c = 0.5$ gives $0.375 \neq 0.4375$.

\item \textbf{Undercut Composition Law}:
$$\mathsf{undercut}(\mathsf{undercut}(c, d_1), d_2) = \mathsf{undercut}(c, d_1 \oplus d_2)$$
This elegantly connects defeat composition to evidence aggregation.

\item \textbf{Rebut Anti-Symmetry}:
$$\mathsf{rebut}(a, b) + \mathsf{rebut}(b, a) = 1$$
The confidences are complementary.

\item \textbf{Derivation Monotonicity}:
$$a \times b \leq \min(a, b)$$
Multiplication is more pessimistic than minimum.
\end{enumerate}

\section{Building and Verifying}

To verify the formalization:

\begin{verbatim}
cd formal/lean
lake exe cache get    # Download Mathlib cache
lake build            # Build and verify all proofs
\end{verbatim}

All proofs type-check successfully with Lean 4 and Mathlib 4, providing
machine-checked verification of CLAIR's confidence algebra foundations.

% Appendix B: Reference Interpreter Design
%
% This appendix contains the Haskell reference interpreter specification
% for CLAIR, demonstrating implementability.

\chapter{Reference Interpreter Design}
\label{app:interpreter}

This appendix provides the complete specification for a Haskell reference
interpreter for CLAIR. While the full implementation is not included in this
dissertation, the design demonstrates that CLAIR is implementable and provides
a testable specification of its semantics.

\section{Design Decisions}

The reference interpreter is designed with the following principles:

\begin{enumerate}
\item \textbf{Clarity over performance}: Every step should be readable and match
the formal specification.
\item \textbf{Completeness over optimization}: Support all language features,
even inefficiently.
\item \textbf{Correctness over speed}: Tests verify behavior against formal semantics.
\end{enumerate}

Key design decisions:

\begin{description}
\item[Language:] Haskell (mature tooling, expressive types, accessibility)
\item[Evaluation:] Strict (confidence computed at derivation time)
\item[Confidence:] Rational numbers (exact arithmetic, matches specification)
\item[Justification:] Hash-consed DAG with explicit node IDs
\item[Errors:] Either monad with typed errors
\item[Invalidation:] Lazy with explicit triggers
\end{description}

\section{Module Structure}

\begin{verbatim}
CLAIR/
  Types.hs           -- Core types (Confidence, Belief, etc.)
  Syntax.hs          -- AST definition
  Parser.hs          -- Surface syntax parser
  TypeChecker.hs     -- Type checking
  Confidence.hs      -- Confidence operations
  Justification.hs   -- Justification DAG operations
  Provenance.hs      -- Provenance tracking
  Invalidation.hs    -- Invalidation checking
  Evaluator.hs       -- Core evaluation
  Primitives.hs      -- Built-in operations
  Main.hs            -- REPL and file execution
\end{verbatim}

\section{Core Types}

\begin{lstlisting}[language=Haskell,caption={CLAIR/Types.hs -- Core type definitions}]
module CLAIR.Types where

import Data.Ratio (Rational, (%))
import Data.IntMap (IntMap)
import Data.Set (Set)

-- | Confidence value in [0,1]
newtype Confidence = Confidence { getConfidence :: Rational }
  deriving (Eq, Ord, Show)

-- | Smart constructor enforcing bounds
mkConfidence :: Rational -> Either String Confidence
mkConfidence r
  | r < 0     = Left "Confidence cannot be negative"
  | r > 1     = Left "Confidence cannot exceed 1"
  | otherwise = Right (Confidence r)

-- | Belief type carrying epistemic metadata
data Belief a = Belief
  { beliefValue         :: a
  , beliefConfidence    :: Confidence
  , beliefProvenance    :: Provenance
  , beliefJustification :: JustificationGraph
  , beliefInvalidation  :: Set Condition
  } deriving (Show, Functor)

-- | Provenance tracking
data Provenance
  = PLiteral                   -- Hardcoded value
  | PInput String              -- External input
  | PDerived [ProvenanceRef]   -- Computed from other beliefs
  | PTraining                  -- From LLM training
  | POracle String             -- External authority
  deriving (Show, Eq)

type ProvenanceRef = Int

-- | Justification graph
type JustificationId = Int

data JustificationGraph = JGraph
  { jgNodes  :: IntMap JustificationNode
  , jgRoot   :: JustificationId
  , jgNextId :: JustificationId
  } deriving (Show)

data JustificationNode
  = JAxiom
  | JRule String [(JustificationId, EdgeType)]
  | JAssumption String
  | JChoice [String] [(String, Rational)] String
  | JAbduction JustificationId [JustificationId] Int String
  | JAnalogy JustificationId JustificationId String
  | JInduction [JustificationId] String
  | JAggregate [JustificationId] CombinationRule
  deriving (Show)

data EdgeType = Support | Undercut | Rebut
  deriving (Show, Eq)

data CombinationRule
  = Independent    -- Use probabilistic OR
  | Conservative   -- Use min
  | Multiplicative -- Use product
  | Correlated Rational  -- Interpolation with dependency
  deriving (Show)

-- | Invalidation conditions
data Condition
  = InputChanged String
  | AssumptionFalse String
  | ConfidenceBelow Confidence
  | ConstraintViolated String
  | TimeElapsed Integer  -- milliseconds
  deriving (Show, Eq, Ord)
\end{lstlisting}

\section{Confidence Operations}

\begin{lstlisting}[language=Haskell,caption={CLAIR/Confidence.hs -- Confidence algebra}]
module CLAIR.Confidence where

import CLAIR.Types
import Data.Ratio ((%))

-- | Confidence multiplication (for derivation)
mulConf :: Confidence -> Confidence -> Confidence
mulConf (Confidence a) (Confidence b) = Confidence (a * b)

-- | Confidence minimum (conservative)
minConf :: Confidence -> Confidence -> Confidence
minConf (Confidence a) (Confidence b) = Confidence (min a b)

-- | Probabilistic OR (for aggregation)
-- a + b = a + b - a*b
oplusConf :: Confidence -> Confidence -> Confidence
oplusConf (Confidence a) (Confidence b) =
  Confidence (a + b - a * b)

-- | Undercut: multiplicative discounting
-- undercut(c, d) = c * (1 - d)
undercutConf :: Confidence -> Confidence -> Confidence
undercutConf (Confidence c) (Confidence d) =
  Confidence (c * (1 - d))

-- | Rebut: probabilistic comparison
-- rebut(c_for, c_against) = c_for / (c_for + c_against)
rebutConf :: Confidence -> Confidence -> Confidence
rebutConf (Confidence cFor) (Confidence cAgainst)
  | cFor + cAgainst == 0 = Confidence (1 % 2)
  | otherwise = Confidence (cFor / (cFor + cAgainst))

-- | Aggregate multiple confidences
aggregateConf :: CombinationRule -> [Confidence] -> Confidence
aggregateConf Independent confs =
  foldr oplusConf (Confidence 0) confs
aggregateConf Conservative confs =
  foldr minConf (Confidence 1) confs
aggregateConf Multiplicative confs =
  foldr mulConf (Confidence 1) confs
aggregateConf (Correlated delta) [c1, c2] =
  let indep = oplusConf c1 c2
      avg = Confidence ((getConfidence c1 + getConfidence c2) / 2)
      Confidence i = indep
      Confidence a = avg
  in Confidence ((1 - delta) * i + delta * a)
aggregateConf (Correlated _) _ =
  error "Correlated aggregation only defined for pairs"

-- | Verify undercut composition law
-- undercut(undercut(c, d1), d2) = undercut(c, d1 `oplus` d2)
prop_undercutCompose :: Confidence -> Confidence -> Confidence -> Bool
prop_undercutCompose c d1 d2 =
  undercutConf (undercutConf c d1) d2 ==
    undercutConf c (oplusConf d1 d2)
\end{lstlisting}

\section{Evaluator Core}

\begin{lstlisting}[language=Haskell,caption={CLAIR/Evaluator.hs -- Core evaluation (excerpt)}]
module CLAIR.Evaluator where

import CLAIR.Types
import CLAIR.Confidence
import Control.Monad.State
import Control.Monad.Except
import qualified Data.Map as Map

-- | Runtime values
data Value
  = VInt Integer
  | VBool Bool
  | VString String
  | VPair Value Value
  | VLeft Value
  | VRight Value
  | VList [Value]
  | VClosure Env String Expr
  | VBelief (Belief Value)
  | VUnit
  deriving (Show)

-- | Environment
type Env = Map.Map String Value

-- | Interpreter state
data InterpreterState = IState
  { isEnv       :: Env
  , isWorld     :: World
  , isNextProv  :: Int
  , isNextJust  :: Int
  }

-- | Errors
data CLAIRError
  = TypeError String
  | ConfidenceOutOfBounds Rational
  | CyclicJustification JustificationId
  | InvalidationTriggered Condition
  | UndefinedVariable String
  | DivisionByZero
  | PatternMatchFailure

-- | The interpreter monad
type CLAIR a = StateT InterpreterState (Either CLAIRError) a

-- | Evaluate an expression
eval :: Expr -> CLAIR Value
eval expr = case expr of
  EVar x -> do
    env <- gets isEnv
    case Map.lookup x env of
      Just v  -> pure v
      Nothing -> throwError (UndefinedVariable x)

  ELam x _ body -> do
    env <- gets isEnv
    pure (VClosure env x body)

  EApp f arg -> do
    fVal <- eval f
    argVal <- eval arg
    case fVal of
      VClosure env' x body -> do
        let env'' = Map.insert x argVal env'
        withEnv env'' (eval body)
      _ -> throwError (TypeError "Expected function")

  -- Belief operations
  EBelief e -> do
    v <- eval e
    pure $ VBelief $ Belief
      { beliefValue = v
      , beliefConfidence = Confidence 1
      , beliefProvenance = PLiteral
      , beliefJustification = axiomJust
      , beliefInvalidation = mempty
      }

  EBeliefAt e c -> do
    v <- eval e
    conf <- evalConfidence c
    pure $ VBelief $ Belief
      { beliefValue = v
      , beliefConfidence = conf
      , beliefProvenance = PLiteral
      , beliefJustification = axiomJust
      , beliefInvalidation = mempty
      }

  EVal e -> do
    v <- eval e
    case v of
      VBelief b -> pure (beliefValue b)
      _ -> throwError (TypeError "Expected belief")

  EDerive beliefs rule combRule -> do
    bVals <- mapM eval beliefs
    bs <- mapM extractBelief bVals
    deriveFromBeliefs rule combRule bs

  -- ... other cases elided for brevity
\end{lstlisting}

\section{Justification DAG Operations}

\begin{lstlisting}[language=Haskell,caption={CLAIR/Justification.hs -- DAG operations}]
module CLAIR.Justification where

import CLAIR.Types
import qualified Data.IntMap as IntMap
import qualified Data.Set as Set

-- | Empty justification graph with axiom root
axiomJust :: JustificationGraph
axiomJust = JGraph
  { jgNodes = IntMap.singleton 0 JAxiom
  , jgRoot = 0
  , jgNextId = 1
  }

-- | Add edge checking for cycles
addJustificationEdge
  :: JustificationId -> JustificationId -> EdgeType
  -> JustificationGraph -> Either CLAIRError JustificationGraph
addJustificationEdge from to edgeType graph = do
  if canReach graph to from
    then Left (CyclicJustification from)
    else Right (insertEdge from to edgeType graph)

-- | Check if there's a path from src to dst
canReach :: JustificationGraph -> JustificationId
         -> JustificationId -> Bool
canReach graph src dst = go mempty src
  where
    go visited current
      | current == dst = True
      | current `Set.member` visited = False
      | otherwise =
          let visited' = Set.insert current visited
              children = getChildren graph current
          in any (go visited') children

-- | Get child nodes from a justification node
getChildren :: JustificationGraph -> JustificationId
            -> [JustificationId]
getChildren graph nodeId =
  case IntMap.lookup nodeId (jgNodes graph) of
    Nothing -> []
    Just node -> case node of
      JAxiom -> []
      JRule _ edges -> map fst edges
      JAssumption _ -> []
      JAbduction obs hyps _ _ -> obs : hyps
      JAnalogy src sim _ -> [src, sim]
      JInduction instances _ -> instances
      JAggregate refs _ -> refs
      _ -> []

-- | Evaluate confidence with defeat (three-pass algorithm)
evaluateConfidenceWithDefeat
  :: JustificationGraph -> JustificationId -> CLAIR Confidence
evaluateConfidenceWithDefeat graph nodeId = do
  let edges = getEdges graph nodeId

  -- Partition edges by type
  let (supports, undercuts, rebuts) = partitionEdges edges

  -- Step 1: Compute base confidence from supports
  supportConfs <- mapM (evaluateConfidenceWithDefeat graph . fst)
                       supports
  let baseConf = aggregateConf Independent supportConfs

  -- Step 2: Apply undercuts
  undercutConfs <- mapM (evaluateConfidenceWithDefeat graph . fst)
                        undercuts
  let combinedUndercut = foldr oplusConf (Confidence 0) undercutConfs
  let afterUndercut = undercutConf baseConf combinedUndercut

  -- Step 3: Compare against rebuts
  rebutConfs <- mapM (evaluateConfidenceWithDefeat graph . fst)
                     rebuts
  let combinedRebut = foldr oplusConf (Confidence 0) rebutConfs
  let finalConf = rebutConf afterUndercut combinedRebut

  pure finalConf

-- | Partition edges by type
partitionEdges :: [(JustificationId, EdgeType)]
               -> ([(JustificationId, EdgeType)],
                   [(JustificationId, EdgeType)],
                   [(JustificationId, EdgeType)])
partitionEdges edges = foldr classify ([], [], []) edges
  where
    classify e@(_, Support)  (s, u, r) = (e:s, u, r)
    classify e@(_, Undercut) (s, u, r) = (s, e:u, r)
    classify e@(_, Rebut)    (s, u, r) = (s, u, e:r)
\end{lstlisting}

\section{Testing Strategy}

The reference interpreter should be validated with:

\subsection{Unit Tests}

\begin{lstlisting}[language=Haskell,caption={Test cases for confidence operations}]
-- Confidence boundedness
prop_confidenceBounded :: Confidence -> Confidence -> Bool
prop_confidenceBounded c1 c2 =
  let result = oplusConf c1 c2
  in getConfidence result >= 0 && getConfidence result <= 1

-- Undercut composition
prop_undercutCompose :: Confidence -> Confidence -> Confidence -> Bool
prop_undercutCompose c d1 d2 =
  undercutConf (undercutConf c d1) d2 ==
    undercutConf c (oplusConf d1 d2)

-- Derivation only decreases confidence
prop_derivationDecreases :: Confidence -> Confidence -> Bool
prop_derivationDecreases c1 c2 =
  let result = mulConf c1 c2
  in result <= c1 && result <= c2

-- Rebut antisymmetry
prop_rebutAntisym :: Confidence -> Confidence -> Property
prop_rebutAntisym c1 c2 =
  getConfidence c1 + getConfidence c2 /= 0 ==>
    let r1 = rebutConf c1 c2
        r2 = rebutConf c2 c1
    in getConfidence r1 + getConfidence r2 == 1
\end{lstlisting}

\subsection{Integration Tests}

\begin{itemize}
\item Derivation chains: Create beliefs, derive new beliefs, verify confidence propagation
\item Defeat scenarios: Test undercut, rebut, and reinstatement
\item Invalidation: Test that invalid beliefs are detected
\end{itemize}

\subsection{Property-Based Tests}

Using QuickCheck:

\begin{itemize}
\item All algebraic properties from Chapter~\ref{ch:confidence}
\item DAG acyclicity invariants
\item Reinstatement correctness
\end{itemize}

\section{Estimated Scope}

The minimal viable reference interpreter is estimated at \textbf{1000--1500 lines of Haskell}:

\begin{center}
\begin{tabular}{lr}
\toprule
Module & Estimated Lines \\
\midrule
Types.hs & 150 \\
Confidence.hs & 100 \\
Justification.hs & 200 \\
Provenance.hs & 50 \\
Invalidation.hs & 100 \\
Evaluator.hs & 300 \\
TypeChecker.hs & 200 \\
Primitives.hs & 100 \\
Tests & 300 \\
\midrule
\textbf{Total} & \textbf{1500} \\
\bottomrule
\end{tabular}
\end{center}

\section{Relationship to Lean Formalization}

The Haskell reference interpreter and Lean formalization serve complementary roles:

\begin{description}
\item[Lean:] Proves properties hold for all inputs (machine-checked correctness)
\item[Haskell:] Demonstrates executability and tests against examples
\end{description}

The types and operations should correspond:

\begin{center}
\begin{tabular}{ll}
\toprule
Lean & Haskell \\
\midrule
\texttt{Confidence} (unitInterval) & \texttt{Confidence} (Rational) \\
\texttt{oplus} & \texttt{oplusConf} \\
\texttt{undercut} & \texttt{undercutConf} \\
\texttt{rebut} & \texttt{rebutConf} \\
\texttt{min} & \texttt{minConf} \\
\bottomrule
\end{tabular}
\end{center}

Future work could extract executable code from the Lean formalization
and compare against the Haskell implementation for additional validation.

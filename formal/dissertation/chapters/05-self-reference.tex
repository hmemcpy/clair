% Chapter 5: Self-Reference and the Gödelian Limits
% Characterizes safe vs dangerous self-reference and develops CPL

\chapter{Self-Reference and the Gödelian Limits}
\label{ch:self-reference}

\epigraph{%
  ``If a system is consistent, it cannot prove its own consistency.''
}{Kurt Gödel, \textit{On Formally Undecidable Propositions}}

CLAIR allows beliefs about beliefs. This reflexive capacity creates potential for
self-reference: a belief that refers to itself, either directly or through a chain
of intermediate beliefs. Such self-reference is both a powerful expressive tool
and a source of potential paradox. This chapter develops the theoretical foundations
for distinguishing safe from dangerous self-reference, culminating in a novel
extension of provability logic to graded confidence.

\section{The Problem of Self-Reference}
\label{sec:self-ref-problem}

Consider a belief that directly references itself:

\begin{lstlisting}[language=CLAIR]
-- A belief referencing its own confidence
let b : Belief<Bool> = belief(
  value: confidence(b) > 0.5,
  confidence: ???
)
\end{lstlisting}

What confidence should \texttt{b} have? If we assign confidence $c > 0.5$, the
content becomes true, which seems consistent. But if we assign $c \leq 0.5$, the
content becomes false---yet what prevents us from assigning $c = 0.9$ anyway?

This is not merely a curiosity. If CLAIR aims to capture how an LLM reasons,
and if introspection is part of reasoning, then CLAIR must account for
self-referential beliefs---even if that account restricts or forbids certain
patterns.

\subsection{Why Self-Reference Matters}

Self-reference enables powerful epistemic capabilities:

\begin{enumerate}
  \item \textbf{Calibration}: ``My confidence estimates are typically accurate''
  \item \textbf{Uncertainty tracking}: ``I am uncertain about this belief''
  \item \textbf{Meta-reasoning}: ``I should reconsider beliefs derived from unreliable sources''
  \item \textbf{Self-improvement}: ``My reasoning process could be improved in specific ways''
\end{enumerate}

But self-reference also enables paradoxes:

\begin{enumerate}
  \item \textbf{Liar-like}: ``This belief has confidence 0'' (no consistent assignment)
  \item \textbf{Curry-like}: ``If this belief is true, then arbitrary proposition $P$'' (proves anything)
  \item \textbf{Löbian}: ``If I believe $P$, then $P$ is true'' (circular self-validation)
\end{enumerate}

The challenge is to permit the former while blocking the latter.

\section{Löb's Theorem and Anti-Bootstrapping}
\label{sec:loeb}

\subsection{The Classical Result}

Löb's theorem \citep{loeb1955solution} is a cornerstone of provability logic:

\begin{theorem}[Löb's Theorem]
\label{thm:loeb}
In any sufficiently strong formal system $T$ containing arithmetic:
\[
  \vdash_T \Box(\Box P \to P) \to \Box P
\]
where $\Box$ denotes provability in $T$.
\end{theorem}

In words: if a system can prove ``if $P$ is provable, then $P$ is true,'' then
the system can prove $P$. This has a startling consequence.

\begin{corollary}[No Internal Soundness Proof]
\label{cor:no-soundness}
No consistent system can prove its own soundness, i.e., cannot prove
$\forall P. \Box P \to P$.
\end{corollary}

\begin{proof}
Suppose system $T$ proved $\forall P. \Box P \to P$. Instantiating with $P = \bot$
(falsity), we get $\Box \bot \to \bot$. Combining with consistency ($\neg \Box \bot$),
we can derive $\Box \bot$, contradicting consistency.
\end{proof}

\subsection{Application to CLAIR}

For CLAIR, interpret $\Box P$ as ``CLAIR believes $P$ with confidence 1.0.'' Then
Löb's theorem constrains self-soundness beliefs:

\begin{lstlisting}[language=CLAIR]
-- A claimed self-soundness belief
let soundness = belief(
  value: forall P. (belief(P, c, ...) and c > 0.9) -> P is true,
  confidence: 0.95
)
\end{lstlisting}

By Löb's theorem, if CLAIR can form this belief with high confidence, then
(classically) CLAIR believes everything with high confidence---a collapse to
triviality. This is the \emph{bootstrapping trap}: self-soundness claims cannot
increase epistemic authority.

\begin{definition}[Anti-Bootstrapping Principle]
\label{def:anti-bootstrap}
A belief system satisfies \emph{anti-bootstrapping} if no belief of the form
``my beliefs are sound'' can increase confidence in any derived belief beyond
what the original evidence supports.
\end{definition}

Löb's theorem mathematically enforces anti-bootstrapping for classical provability.
The question is how this extends to graded confidence.

\section{Tarski's Hierarchy: Stratified Introspection}
\label{sec:tarski}

\subsection{The Classical Solution}

Tarski's theorem on the undefinability of truth \citep{tarski1933} states that no
sufficiently expressive language can define its own truth predicate---on pain of
the Liar paradox. Tarski's solution is stratification:

\begin{center}
\begin{tabular}{lll}
\toprule
\textbf{Level} & \textbf{Can Express} & \textbf{Cannot Express} \\
\midrule
Level 0 (object) & Facts about the world & Truth of any sentence \\
Level 1 (meta) & ``$X_0$ is true'' for level-0 $X$ & Truth of level-1 sentences \\
Level 2 (meta-meta) & ``$X_1$ is true'' for level-1 $X$ & Truth of level-2 sentences \\
$\vdots$ & $\vdots$ & $\vdots$ \\
\bottomrule
\end{tabular}
\end{center}

Each level can discuss truth at lower levels but never its own level.

\subsection{Stratified Beliefs in CLAIR}

We apply this to beliefs:

\begin{definition}[Stratified Belief Type]
\label{def:stratified-belief}
\[
  \Bel{n, A} \text{ for } n \in \mathbb{N}
\]
where level-$n$ beliefs may reference level-$m$ beliefs only if $m < n$.
\end{definition}

\begin{lstlisting}[language=CLAIR]
-- Level 0: beliefs about the world (no introspection)
type Belief_0<A>

-- Level n: beliefs that may reference level-(n-1) beliefs
type Belief<n : Nat, A> where
  n > 0 implies A may mention Belief<m, B> for any m < n

-- Examples:
let auth : Belief<0, Bool> = belief("user authenticated", 0.9, ...)

let meta_auth : Belief<1, String> = belief(
  "my auth belief has confidence " ++ show(auth.confidence),
  0.95,
  derives_from: [auth]
)

let meta_meta : Belief<2, String> = belief(
  "my level-1 introspection seems accurate",
  0.9,
  derives_from: [meta_auth]
)
\end{lstlisting}

\begin{theorem}[Stratification Safety]
\label{thm:stratification-safety}
If all beliefs respect the stratification constraint---$\Bel{n, A}$ references
only $\Bel{m, B}$ with $m < n$---then no Liar-like paradox can arise.
\end{theorem}

\begin{proof}
Any reference chain from a belief $b$ must strictly decrease in level. Since
$\mathbb{N}$ has no infinite descending chains, every chain terminates at level 0.
Level-0 beliefs contain no belief references, so they cannot participate in
self-referential loops. Therefore, no belief can reference itself directly or
transitively.
\end{proof}

\subsection{What Stratification Rules Out}

Stratification prohibits:

\begin{itemize}
  \item \textbf{Direct self-reference}: A belief cannot mention itself (would
        require level $n < n$).
  \item \textbf{Universal introspection}: ``All my beliefs are...'' spans all
        levels and cannot be expressed at any finite level.
  \item \textbf{Self-soundness at a single level}: ``My level-$n$ beliefs are
        sound'' would require level $n+1$ to express.
\end{itemize}

\subsection{The Cost of Safety}

Stratification is safe but restrictive. Some legitimate self-referential
reasoning is blocked:

\begin{lstlisting}[language=CLAIR]
-- Legitimate but blocked: calibration beliefs
let calibrated = belief(
  "my confidence estimates match empirical accuracy",
  0.8,
  ...
)
-- This is self-referential (talks about own confidences)
-- but intuitively safe (no paradox)
\end{lstlisting}

This motivates a more permissive approach for certain cases.

\section{Kripke's Fixed Points: Safe Self-Reference}
\label{sec:kripke}

\subsection{The Fixed-Point Construction}

Kripke \citep{kripke1975outline} proposed an alternative to stratification:
allow self-reference but let some sentences remain \emph{undefined}. The key
insight is that certain self-referential constructs have \emph{fixed points}---
consistent confidence assignments---while others do not.

\begin{definition}[Fixed Point for Self-Referential Belief]
\label{def:fixed-point}
A self-referential belief $b$ with confidence function $f : [0,1] \to [0,1]$
(determining confidence from the assumed truth value) has a fixed point if
there exists $c \in [0,1]$ such that:
\[
  c = f(c)
\]
\end{definition}

\begin{example}[Truth-Teller: Multiple Fixed Points]
\label{ex:truth-teller}
Consider:
\begin{lstlisting}[language=CLAIR]
let tt = self_ref_belief(fun self =>
  content: "this belief is true",
  compute_confidence: if val(self.content) then 1.0 else 0.0
)
\end{lstlisting}
If confidence is 1.0: content is true, so confidence should be 1.0. $\checkmark$
If confidence is 0.0: content is false, so confidence should be 0.0. $\checkmark$

Both are fixed points. The belief is \emph{underdetermined}.
\end{example}

\begin{example}[Liar: No Fixed Point]
\label{ex:liar}
Consider:
\begin{lstlisting}[language=CLAIR]
let liar = self_ref_belief(fun self =>
  content: "this belief has confidence 0",
  compute_confidence: if val(self.content) then 1.0 else 0.0
)
\end{lstlisting}
If confidence is 1.0: content says ``confidence 0,'' which is false, so confidence
should be 0.0. Contradiction.
If confidence is 0.0: content says ``confidence 0,'' which is true, so confidence
should be 1.0. Contradiction.

No fixed point exists. The belief is \emph{ill-formed}.
\end{example}

\begin{example}[Grounded Self-Reference: Unique Fixed Point]
\label{ex:grounded}
Consider:
\begin{lstlisting}[language=CLAIR]
let careful = self_ref_belief(fun self =>
  content: "confidence(self) is in [0.4, 0.6]",
  compute_confidence: 0.5
)
\end{lstlisting}
The compute function is constant, so $f(c) = 0.5$ for all $c$.
The fixed point is $c = 0.5$, which indeed satisfies $0.5 \in [0.4, 0.6]$.
This belief is \emph{well-formed} with unique confidence 0.5.
\end{example}

\subsection{The Self-Reference Escape Hatch}

CLAIR provides a controlled mechanism for self-reference:

\begin{lstlisting}[language=CLAIR]
-- Self-referential belief constructor
self_ref_belief :
  {A : Type} ->
  (compute : Belief<infinity, A> -> BeliefContent<A>) ->
  SelfRefResult<A>

data SelfRefResult<A> =
  | WellFormed (Belief<infinity, A>)      -- unique fixed point
  | IllFormed (reason : SelfRefError)    -- no fixed point
  | Underdetermined (points : List<Confidence>)  -- multiple fixed points

data SelfRefError =
  | NoFixedPoint        -- Liar-like
  | CurryLike           -- proves anything
  | LobianTrap          -- self-soundness
  | Timeout             -- computation did not terminate
\end{lstlisting}

The \texttt{Belief<infinity, A>} type indicates beliefs that escape the stratification
hierarchy---they exist ``outside'' all finite levels.

\subsection{Classification of Self-Reference}

Combining Tarski and Kripke, we classify self-referential constructs:

\begin{table}[htbp]
\centering
\caption{Classification of Self-Referential Constructs}
\label{tab:self-ref-classification}
\begin{tabular}{llll}
\toprule
\textbf{Category} & \textbf{Fixed Points} & \textbf{Status} & \textbf{Example} \\
\midrule
Grounded & Unique & Safe & Calibration beliefs \\
Underdetermined & Multiple & Policy choice & Truth-teller \\
Liar-like & None & Ill-formed & ``Confidence is 0'' \\
Curry-like & --- & Banned & ``If true, then $P$'' \\
Löbian & --- & Banned & Self-soundness \\
\bottomrule
\end{tabular}
\end{table}

\begin{definition}[Safe Self-Reference]
\label{def:safe-self-ref}
A self-referential belief is \emph{safe} if it either:
\begin{enumerate}
  \item Respects stratification (level-$n$ references only level-$m < n$), or
  \item Has a unique fixed point (Kripke), or
  \item Has multiple fixed points with a deterministic policy for selection.
\end{enumerate}
\end{definition}

\begin{definition}[Dangerous Self-Reference]
\label{def:dangerous-self-ref}
A self-referential belief is \emph{dangerous} if it:
\begin{enumerate}
  \item Has no fixed point (Liar-like), or
  \item Matches a Curry pattern (``if this then $P$''), or
  \item Claims self-soundness (Löbian trap).
\end{enumerate}
\end{definition}

\section{Provability Logic and CLAIR}
\label{sec:gl}

\subsection{Gödel-Löb Logic (GL)}

To formally characterize CLAIR's belief logic, we turn to \emph{provability logic}
\citep{boolos1993logic}. The standard modal logic of provability is GL (Gödel-Löb):

\begin{definition}[GL Syntax]
\label{def:gl-syntax}
\[
  \varphi ::= p \mid \neg\varphi \mid \varphi \land \psi \mid \varphi \lor \psi
              \mid \varphi \to \psi \mid \Box\varphi
\]
where $\Box\varphi$ means ``$\varphi$ is provable.''
\end{definition}

\begin{definition}[GL Axioms]
\label{def:gl-axioms}
\begin{align}
  \text{K (Distribution):} \quad & \Box(\varphi \to \psi) \to (\Box\varphi \to \Box\psi) \\
  \text{4 (Introspection):} \quad & \Box\varphi \to \Box\Box\varphi \\
  \text{L (Löb):} \quad & \Box(\Box\varphi \to \varphi) \to \Box\varphi
\end{align}
\end{definition}

Critically, GL \emph{lacks} the truth axiom $\Box\varphi \to \varphi$ (T). This is
philosophically essential: provability does not imply truth. A consistent system
can prove false statements if its axioms are wrong.

\subsection{GL vs Other Modal Logics}

\begin{table}[htbp]
\centering
\caption{Comparison of Modal Logics}
\label{tab:modal-comparison}
\begin{tabular}{lcccc}
\toprule
\textbf{Logic} & \textbf{K} & \textbf{T} & \textbf{4} & \textbf{5 or L} \\
\midrule
K & $\checkmark$ & & & \\
T & $\checkmark$ & $\checkmark$ & & \\
S4 & $\checkmark$ & $\checkmark$ & $\checkmark$ & \\
S5 & $\checkmark$ & $\checkmark$ & $\checkmark$ & 5 \\
GL & $\checkmark$ & & $\checkmark$ & L \\
\midrule
\textbf{CLAIR} & $\checkmark$ & & $\checkmark$ & L \\
\bottomrule
\end{tabular}
\end{table}

CLAIR aligns with GL:
\begin{itemize}
  \item \textbf{K} holds: If CLAIR believes an implication and believes the
        antecedent, it can derive the consequent.
  \item \textbf{T} fails: CLAIR's beliefs can be wrong (fallibilism).
  \item \textbf{4} holds: CLAIR can have meta-beliefs about its beliefs.
  \item \textbf{L} must hold: Self-soundness claims cannot bootstrap confidence.
\end{itemize}

\subsection{Solovay's Completeness}

\begin{theorem}[Solovay, 1976]
\label{thm:solovay}
GL is sound and complete with respect to:
\begin{enumerate}
  \item Arithmetic provability: $\GL \vdash \varphi$ iff $\varphi$ holds under all
        interpretations of $\Box$ as Gödel provability in PA.
  \item Finite transitive irreflexive Kripke frames.
\end{enumerate}
\end{theorem}

The completeness for finite frames yields:

\begin{corollary}[GL Decidability]
\label{cor:gl-decidable}
GL is decidable (PSPACE-complete).
\end{corollary}

This is crucial: classical provability logic is computationally tractable.

\section{Confidence-Bounded Provability Logic (CPL)}
\label{sec:cpl}

Classical GL uses binary truth: propositions are either provable or not. CLAIR
needs a \emph{graded} version where beliefs carry confidence values in $[0,1]$.
This section introduces CPL (Confidence-Bounded Provability Logic), a novel
extension of GL designed for CLAIR.

\subsection{The Literature Gap}

Extensive work exists on fuzzy modal logics \citep{godo2003many, caicedo2013godel}
and graded epistemic logic. However, no prior work addresses:

\begin{itemize}
  \item Graded versions of the Löb axiom
  \item The interaction of continuous confidence with provability constraints
  \item Anti-bootstrapping in the context of graded belief
\end{itemize}

CPL fills this gap.

\subsection{CPL Syntax}

\begin{definition}[CPL Syntax]
\label{def:cpl-syntax}
\[
  \varphi ::= p \mid \neg\varphi \mid \varphi \land \psi \mid \varphi \lor \psi
              \mid \varphi \to \psi \mid \Bop{c}\varphi
\]
where $\Bop{c}\varphi$ means ``$\varphi$ is believed with confidence at least $c$.''
\end{definition}

\subsection{CPL Semantics}

\begin{definition}[Graded Kripke Frame]
\label{def:graded-kripke}
A \emph{graded Kripke frame} is a tuple $(W, R)$ where:
\begin{itemize}
  \item $W$ is a non-empty set of worlds
  \item $R : W \times W \to [0,1]$ is a graded accessibility relation
\end{itemize}
satisfying:
\begin{enumerate}
  \item \textbf{Transitivity}: $R(w,v) \otimes R(v,u) \leq R(w,u)$
  \item \textbf{Converse well-foundedness}: No infinite sequence
        $w_0, w_1, w_2, \ldots$ with $R(w_{i+1}, w_i) > 0$ for all $i$
\end{enumerate}
\end{definition}

\begin{definition}[Graded Valuation]
\label{def:graded-valuation}
A \emph{graded valuation} on a frame $(W, R)$ assigns to each world $w$ and
proposition $p$ a confidence value $V_w(p) \in [0,1]$. Extended to formulas:
\begin{align}
  V_w(\neg\varphi) &= 1 - V_w(\varphi) \\
  V_w(\varphi \land \psi) &= V_w(\varphi) \otimes V_w(\psi) \\
  V_w(\varphi \lor \psi) &= V_w(\varphi) \oplus V_w(\psi) \\
  V_w(\varphi \to \psi) &= \sup\{c \in [0,1] : V_w(\varphi) \otimes c \leq V_w(\psi)\} \\
  V_w(\Bop{c}\varphi) &= \inf_{v : R(w,v) \geq c} V_v(\varphi)
\end{align}
\end{definition}

The last clause says: $\varphi$ is believed at confidence $c$ if $\varphi$ holds
in all worlds accessible with strength at least $c$.

\subsection{The Graded Löb Axiom}

The crucial innovation in CPL is the graded analogue of Löb's axiom:

\begin{axiom}[Graded Löb]
\label{ax:graded-loeb}
\[
  \Bop{c}(\Bop{c}\varphi \to \varphi) \to \Bop{g(c)}\varphi
\]
where $g : [0,1] \to [0,1]$ is a \emph{discount function} satisfying $g(c) \leq c$.
\end{axiom}

The function $g$ captures the \emph{cost} of self-soundness claims. If you believe
at confidence $c$ that ``believing $\varphi$ at $c$ implies $\varphi$,'' you can
derive $\varphi$ only at the discounted confidence $g(c)$.

\subsection{Choosing the Discount Function}

We require $g$ to satisfy:

\begin{enumerate}
  \item \textbf{Boundedness}: $g : [0,1] \to [0,1]$
  \item \textbf{Non-amplification}: $g(c) \leq c$ for all $c$
  \item \textbf{Monotonicity}: $c_1 \leq c_2 \Rightarrow g(c_1) \leq g(c_2)$
  \item \textbf{Anchoring}: $g(0) = 0$ and $g(1) = 1$
  \item \textbf{Non-triviality}: $g(c) < c$ for $c \in (0,1)$
\end{enumerate}

After analyzing several candidates (identity, parabolic, constant offset, product),
we recommend:

\begin{definition}[Quadratic Discount]
\label{def:quadratic-discount}
\[
  g(c) = c^2
\]
\end{definition}

\begin{theorem}[Quadratic Discount Properties]
\label{thm:quadratic-properties}
The quadratic discount $g(c) = c^2$ satisfies all desiderata and:
\begin{enumerate}
  \item Aligns with CLAIR's multiplicative confidence algebra ($c^2 = c \times c$)
  \item Has intuitive meaning: self-soundness costs ``deriving the claim twice''
  \item Produces strong anti-bootstrapping: iterated application $c \to c^2 \to c^4 \to \cdots \to 0$
\end{enumerate}
\end{theorem}

\begin{proof}
Boundedness and anchoring are immediate ($c \in [0,1] \Rightarrow c^2 \in [0,1]$,
$0^2 = 0$, $1^2 = 1$). For non-amplification: $c^2 \leq c$ when $c \leq 1$, with
equality only at 0 and 1. Monotonicity: $c_1 \leq c_2 \Rightarrow c_1^2 \leq c_2^2$
on $[0,1]$. Non-triviality: $c^2 < c$ for $c \in (0,1)$.
\end{proof}

\subsection{The Anti-Bootstrapping Theorem}

\begin{theorem}[Anti-Bootstrapping]
\label{thm:anti-bootstrap}
In CPL with $g(c) = c^2$:
\[
  \conf(\Bop{c}(\Bop{c}\varphi \to \varphi)) = c \quad\Rightarrow\quad
  \conf(\varphi) \leq c^2 < c
\]
Consequently, no finite chain of self-soundness claims can increase confidence
beyond the initial level.
\end{theorem}

\begin{proof}
Applying the Graded Löb axiom to the hypothesis yields $\conf(\Bop{c^2}\varphi)
\leq c^2$. Iterating: $c \to c^2 \to c^4 \to c^8 \to \cdots$. For any $c < 1$,
this sequence converges to 0. Self-soundness claims can only decrease confidence.
\end{proof}

This is the mathematical formalization of anti-bootstrapping: claiming your own
soundness provides no epistemic free lunch.

\section{Decidability of CPL}
\label{sec:cpl-decidability}

Classical GL is decidable. Does CPL inherit this property?

\subsection{The Vidal Result}

\begin{theorem}[Vidal, 2019]
\label{thm:vidal}
Transitive modal logics over many-valued semantics (including Łukasiewicz and
Product algebras) are undecidable, even when restricted to finite models.
\end{theorem}

CPL has transitivity (axiom 4) and continuous $[0,1]$ values. The Vidal result
strongly suggests:

\begin{conjecture}[CPL Undecidability]
\label{conj:cpl-undecidable}
Full CPL (with continuous $[0,1]$ confidence) is undecidable.
\end{conjecture}

We assign confidence 0.80 to this conjecture based on the close analogy to Vidal's
proof technique.

\subsection{The Role of Converse Well-Foundedness}

GL's decidability relies on the finite model property: converse well-foundedness
forces finite-depth evaluation. Could this rescue CPL?

\begin{proposition}[Insufficient for Decidability]
\label{prop:cwf-insufficient}
Converse well-foundedness alone does not rescue CPL from undecidability.
\end{proposition}

The intuition: converse well-foundedness constrains \emph{structure} (no infinite
ascending chains) but not \emph{values}. The encoding power of continuous
$[0,1]$ values combined with transitivity enables undecidable problem encodings
even in well-founded frames.

\subsection{Decidable Fragments}

Despite the likely undecidability of full CPL, we identify decidable fragments:

\subsubsection{CPL-finite: Discrete Confidence}

Restrict confidence to a finite lattice instead of continuous $[0,1]$:

\begin{definition}[CPL-finite]
\label{def:cpl-finite}
Let $L_n = \{0, \frac{1}{n-1}, \frac{2}{n-1}, \ldots, 1\}$. CPL-finite evaluates
over $L_n$ with discretized operations:
\begin{align}
  a \otimes b &= \floorL{a \times b} \\
  a \oplus b &= \ceilL{a + b - ab} \\
  g_L(c) &= \floorL{c^2}
\end{align}
\end{definition}

For $L_5 = \{0, 0.25, 0.5, 0.75, 1\}$:

\begin{table}[htbp]
\centering
\caption{Löb Discount on $L_5$}
\label{tab:l5-discount}
\begin{tabular}{ccc}
\toprule
$c$ & $c^2$ & $g_{L_5}(c)$ \\
\midrule
0 & 0 & 0 \\
0.25 & 0.0625 & 0 \\
0.5 & 0.25 & 0.25 \\
0.75 & 0.5625 & 0.5 \\
1 & 1 & 1 \\
\bottomrule
\end{tabular}
\end{table}

\begin{theorem}[CPL-finite Decidability]
\label{thm:cpl-finite-decidable}
CPL-finite is decidable via the finite model property.
\end{theorem}

\begin{proof}[Proof sketch]
By the theorem of Bou, Esteva, and Godo \citep{bou2011finite}, many-valued modal
logics over finite residuated lattices are decidable. CPL-finite evaluates over
$L_n$, a finite lattice. The frame constraints (transitivity, converse well-foundedness)
are expressible, and finitely many models of bounded size suffice for completeness.
\end{proof}

\begin{conjecture}[CPL-finite Complexity]
\label{conj:cpl-finite-complexity}
CPL-finite is PSPACE-complete, analogous to classical GL.
\end{conjecture}

\subsubsection{CPL-0: Stratified Only}

Restrict to stratified beliefs without any self-reference:

\begin{definition}[CPL-0]
\label{def:cpl-zero}
CPL-0 disallows nesting of $\Box$ operators that would require the Löb axiom.
Formally: only formulas of the form $\Bop{c}\varphi$ where $\varphi$ is box-free.
\end{definition}

\begin{theorem}[CPL-0 Decidability]
\label{thm:cpl-zero-decidable}
CPL-0 is decidable (trivially: the restricted syntax avoids undecidability).
\end{theorem}

\subsection{Trade-offs}

\begin{table}[htbp]
\centering
\caption{CPL Fragment Trade-offs}
\label{tab:cpl-tradeoffs}
\begin{tabular}{llll}
\toprule
\textbf{Fragment} & \textbf{Decidable?} & \textbf{Expressiveness} & \textbf{Use Case} \\
\midrule
Full CPL & Likely no & Full & Theoretical analysis \\
CPL-finite & Yes & Discrete confidence & Type-level checks \\
CPL-0 & Yes & No self-reference & Stratified beliefs \\
\bottomrule
\end{tabular}
\end{table}

\section{Alternative: CPL-Gödel}
\label{sec:cpl-godel}

An alternative approach uses Gödel algebra (min/max) instead of product operations:

\begin{definition}[CPL-Gödel]
\label{def:cpl-godel}
\begin{align}
  a \otimes b &= \min(a, b) \\
  a \oplus b &= \max(a, b)
\end{align}
\end{definition}

\begin{theorem}[CPL-Gödel Likely Decidable]
\label{thm:cpl-godel-decidable}
CPL-Gödel is likely decidable because Gödel modal logic has the finite model
property via quasimodels \citep{caicedo2013godel}.
\end{theorem}

However, CPL-Gödel is \emph{semantically inappropriate} for CLAIR:

\begin{itemize}
  \item \textbf{max fails aggregation}: $\max(0.6, 0.6) = 0.6$, but two independent
        pieces of evidence should yield higher confidence (0.84 with $\oplus$).
  \item \textbf{min lacks degradation}: $\min(a, a) = a$, but derivation should
        cost confidence.
  \item \textbf{No algebraic discount}: The $c^2$ discount becomes purely
        frame-based, losing the anti-bootstrapping semantics.
\end{itemize}

\begin{recommendation}
For CLAIR, use CPL-finite (with product operations), not CPL-Gödel. Accept the
discretization rather than sacrifice semantic fidelity.
\end{recommendation}

\section{Design Recommendations for CLAIR}
\label{sec:self-ref-design}

\subsection{The Two-Layer Approach}

CLAIR should implement a two-layer approach to self-reference:

\begin{enumerate}
  \item \textbf{Default: Stratification}. All beliefs are level-indexed.
        $\Bel{n, A}$ can only reference $\Bel{m, B}$ with $m < n$. This is
        safe by construction and requires no runtime analysis.

  \item \textbf{Escape hatch: Kripke fixed points}. For legitimate self-reference
        (calibration, uncertainty tracking), use \texttt{self\_ref\_belief} which
        computes fixed points at construction time. Ill-formed constructs are
        rejected.
\end{enumerate}

\subsection{Hard Bans}

Certain patterns are syntactically rejected:

\begin{itemize}
  \item \textbf{Curry patterns}: ``If [self-reference] then [arbitrary $P$]''
  \item \textbf{Explicit self-soundness}: Claims of the form ``All my beliefs are sound''
  \item \textbf{Unrestricted quantification}: ``For all beliefs $b$, ...''
\end{itemize}

These are detected by the parser and rejected before type checking.

\subsection{Type-Level Anti-Bootstrapping}

For type-level confidence checks, use CPL-finite with $L_5$:

\begin{lstlisting}[language=Lean]
-- Finite confidence for compile-time checks
inductive FiniteConfidence where
  | zero  : FiniteConfidence  -- 0
  | low   : FiniteConfidence  -- 0.25
  | mid   : FiniteConfidence  -- 0.5
  | high  : FiniteConfidence  -- 0.75
  | one   : FiniteConfidence  -- 1

def loebDiscount : FiniteConfidence -> FiniteConfidence
  | .zero => .zero
  | .low  => .zero   -- 0.25^2 = 0.0625 -> floor to 0
  | .mid  => .low    -- 0.5^2  = 0.25
  | .high => .mid    -- 0.75^2 = 0.5625 -> floor to 0.5
  | .one  => .one
\end{lstlisting}

This provides decidable type-level constraints while preserving the anti-bootstrapping
semantics.

\section{Related Work}
\label{sec:self-ref-related}

\subsection{Provability Logic}

The foundations of provability logic are in \citet{boolos1993logic}, with the
Solovay completeness theorems establishing the connection to arithmetic. Modern
work on GL extensions includes \citet{beklemishev2004provability} on polymodal
variants.

\subsection{Self-Reference in AI}

\citet{xue2024loeb} address Löb-safe logics for AI reasoning but in classical
(non-graded) settings. \citet{garrabrant2016logical} develop logical inductors
as an approach to coherent self-reference, though in a different formal framework.

\subsection{Fuzzy Modal Logic}

Fuzzy extensions of modal logic are surveyed in \citet{godo2003many}. Decidability
results for finite-valued logics appear in \citet{bou2011finite}. The critical
undecidability result for transitive many-valued logics is \citet{vidal2019transitive}.

\section{Conclusion}
\label{sec:self-ref-conclusion}

This chapter characterized the landscape of self-reference in CLAIR:

\begin{enumerate}
  \item \textbf{Löb's theorem applies}: Self-soundness claims cannot bootstrap
        epistemic authority. This is a mathematical fact, not a design choice.

  \item \textbf{Stratification is safe}: Tarski-style level indexing prevents
        all self-referential paradoxes by construction.

  \item \textbf{Fixed points enable safe self-reference}: Kripke's approach
        permits legitimate introspection (calibration, uncertainty tracking)
        while rejecting ill-formed constructs.

  \item \textbf{CPL extends GL to graded confidence}: The Graded Löb axiom with
        $g(c) = c^2$ captures anti-bootstrapping for continuous confidence.

  \item \textbf{Full CPL is likely undecidable}: Transitivity plus continuous
        values enables undecidability (Vidal 2019).

  \item \textbf{CPL-finite is decidable}: Restricting to discrete confidence
        yields a tractable fragment suitable for type-level checks.

  \item \textbf{Two-layer design}: Stratification by default, Kripke fixed points
        as escape hatch, hard bans on dangerous patterns.
\end{enumerate}

The Gödelian limits are not obstacles but design constraints. They tell us what
epistemic claims are coherent and which collapse into triviality. By respecting
these limits, CLAIR achieves honest self-awareness: it can reason about its own
reasoning without falling into paradox.

The next chapter turns to epistemological foundations: what grounds CLAIR's
beliefs in the first place.

%% ============================================================================
%% BIBLIOGRAPHY NOTES
%% ============================================================================
%
% Key citations for this chapter:
%
% Classical:
% - loeb1955solution: Löb's theorem
% - tarski1933: Undefinability of truth
% - kripke1975outline: Fixed-point theory of truth
% - boolos1993logic: The Logic of Provability
% - gupta1993revision: Revision Theory of Truth
%
% Decidability:
% - vidal2019transitive: Undecidability of transitive many-valued modal logics
% - bou2011finite: Decidability of finite-valued modal logics
% - caicedo2013godel: Gödel modal logic decidability
%
% AI and self-reference:
% - xue2024loeb: Löb-safe logics
% - garrabrant2016logical: Logical inductors
%
